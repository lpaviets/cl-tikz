* Intro

This project tries to make it easier to produce images that can be embedded in LaTeX documents. In particular, this projects acts as a Lisp wrapper around TikZ.
As TikZ's syntax is sometimes obtuse, and as computations done directly with the TeX engine are either hard to do (due to TikZ's syntax, LaTeX limitations ...), or really, we try to do most of the work in a more powerful programming language, and we directly generate "low-level" TikZ. As such, the TikZ code that is output does not contain computationally-intensive macros, and we try to do as much maths as possible (rotations, loops ...) in Common Lisp beforehand.

As most of personal research work involves tilings, Wang tiles, subshifts and several other combinatoric objects such as cellular automata or substitutions, a major part of the project is directed towards this objective, /e.g./ making it is easy to define Wang tiles and how to draw them. This also involves writing algorithms that are not directly related to the task of producing TikZ code. I try to separate the "drawing" and the "computing" part whenever this makes sense, but it is not always possible.

*REMARK:* this project is still heavily WIP. This means that no stable API exists yet, and everything is subject to change. Nevertheless, I still think it might be useful, if only as some proof-of-concept.

* Example
Example of the famous Robinson tiling:

Thi is part of the code used to define the tileset, which includes indications on how to draw the individual tiles, their adjacency rules and so on (not shown here)
#+begin_src lisp
  (defvar *robinson*
    (let ((robinson-tiles (make-hash-table :test 'eq)))
      (dolist (tile (list (make-robinson-tile 'robinson t t
                                              '(:green :center :out)
                                              '(:red :left :out)
                                              '(:red :up :out)
                                              '(:green :center :out))
                          (make-robinson-tile 'robinson t nil
                                              '(:green :center :out)
                                              '(:red :left :out)
                                              '(:red :up :out)
                                              '(:green :center :out))
                          ;; more tiles
                          (make-robinson-tile 'robinson nil nil
                                              '(:red :up :in)
                                              '(:red :right :in)
                                              '(:red :up :in)
                                              '(:red :right :out))))
        (dotimes (turns 4)
          (setf (gethash (make-rotated-tile tile turns) robinson-tiles) t)))
      (make-tileset 'robinson robinson-tiles)))
#+end_src

If we try to use this tileset to tile a 10-by-10 grid with one of the included solvers, we get the following LaTeX code:

#+begin_src LaTeX :export t
  %%% CODE AUTO GENERATED BY THE CL-TIKZ PACKAGE

  \documentclass{standalone}
  \usepackage{tikz}
  \usepackage[utf8]{inputenc}
  \usepackage{pgfmath}
  \usetikzlibrary{arrows, shapes, decorations.markings, decorations.pathmorphing}

  \begin{document}
  \begin{tikzpicture}
  \draw[] (-0.50, -0.50) rectangle (0.50, 0.50);
  \draw[decoration={markings, mark=at position 0.7 with {\arrowreversed{latex}}}, postaction={decorate}, green] (0.00, 0.00) -- (0.00, 0.50);
  \draw[decoration={markings, mark=at position 0.7 with {\arrowreversed{latex}}}, postaction={decorate}, red] (0.00, -0.25) -- (-0.50, -0.25);
  \draw[decoration={markings, mark=at position 0.7 with {\arrowreversed{latex}}}, postaction={decorate}, green] (0.00, 0.00) -- (0.00, -0.50);
  \draw[decoration={markings, mark=at position 0.98 with {\arrow{latex}}}, postaction={decorate}, red] (0.00, -0.25) -- (0.50, -0.25);
  \draw[] (0.50, -0.50) rectangle (1.50, 0.50);
  \draw[decoration={markings, mark=at position 0.7 with {\arrowreversed{latex}}}, postaction={decorate}, red] (1.25, 0.00) -- (1.25, 0.50);
  \draw[decoration={markings, mark=at position 0.7 with {\arrowreversed{latex}}}, postaction={decorate}, red] (1.00, -0.25) -- (0.50, -0.25);
  \draw[decoration={markings, mark=at position 0.7 with {\arrowreversed{latex}}}, postaction={decorate}, red] (1.25, 0.00) -- (1.25, -0.50);
  \draw[decoration={markings, mark=at position 0.98 with {\arrow{latex}}}, postaction={decorate}, red] (1.00, -0.25) -- (1.50, -0.25);
  [...]
  \draw[] (7.50, 8.50) rectangle (8.50, 9.50);
  \draw[fill=yellow] (7.50, 8.50) rectangle (7.55, 8.55);
  \draw[fill=yellow] (7.50, 9.45) rectangle (7.55, 9.50);
  \draw[fill=yellow] (8.45, 8.50) rectangle (8.50, 8.55);
  \draw[fill=yellow] (8.45, 9.45) rectangle (8.50, 9.50);
  \draw[decoration={markings, mark=at position 0.98 with {\arrow{latex}}}, postaction={decorate}, red] (8.25, 8.75) -- (8.25, 9.50);
  \draw[decoration={markings, mark=at position 0.98 with {\arrow{latex}}}, postaction={decorate}, red] (8.25, 8.75) -- (7.50, 8.75);
  \draw[decoration={markings, mark=at position 0.98 with {\arrow{latex}}}, postaction={decorate}, green] (8.00, 9.00) -- (8.00, 8.50);
  \draw[decoration={markings, mark=at position 0.98 with {\arrow{latex}}}, postaction={decorate}, green] (8.00, 9.00) -- (8.50, 9.00);
  \draw[] (8.50, 8.50) rectangle (9.50, 9.50);
  \draw[decoration={markings, mark=at position 0.7 with {\arrowreversed{latex}}}, postaction={decorate}, red] (9.25, 9.00) -- (9.25, 9.50);
  \draw[decoration={markings, mark=at position 0.7 with {\arrowreversed{latex}}}, postaction={decorate}, green] (9.00, 9.00) -- (8.50, 9.00);
  \draw[decoration={markings, mark=at position 0.98 with {\arrow{latex}}}, postaction={decorate}, red] (9.25, 9.00) -- (9.25, 8.50);
  \draw[decoration={markings, mark=at position 0.7 with {\arrowreversed{latex}}}, postaction={decorate}, green] (9.00, 9.00) -- (9.50, 9.00);
  \end{tikzpicture}
  \end{document}

  %%% Local Variables:
  %%% mode: latex
  %%% TeX-master: t
  %%% End:
#+end_src

which produces, when compiled, the following image:
(note: this is a PNG for inline purposes. The actual PDF file is [[file:robinson.pdf][here]])

[[file:robinson.png]]

* Todo
- Link the tiling implementation and the Dancing Links implementation, to use it as a solver.
#+begin_src lisp
;; See https://github.com/seblabbe/slabbe/blob/d8340eeb5fdccffc6c28ab6c3b0e6d68177bb676/slabbe/wang_tiles.py#L2902
;; for a Python implementation of the same idea,
;; as well as https://github.com/seblabbe/slabbe/blob/d8340eeb5fdccffc6c28ab6c3b0e6d68177bb676/slabbe/wang_tiles.py#L2679

;; View the problem as a set of constraints
;; - Each cell of the grid must contain one, and exactly one, tile
;; - No two adjacent cells can contain "invalid" patterns
#+end_src

- More efficient solvers in general
- Cellular automata
- Generic SFTs (not only Wang tiles/radius-1 rules)
- Substitutions
